## 地址空间

**byte**: 所有常用字母大概有 128 个.如 ascii.使用 7 个数位可以表示所有状态.IBM机器加上了一个最高位,共 8 位.故一个`char`是 8 位.类型为 byte.甚至可以记忆`byte=by eight`.在 C 标准库中,`limits.h`定义了一个 char 就是 8 位.

**地址与 byte**:byte 是最小的寻址单位,每个 byte 占据一个地址.因此,在C的栈结构中,栈宽度都是 8(bit).

```
|||||||||  <- 一个 byte
|||||||||
|||||||||
|||||||||
|||||||||
|||||||||
|||||||||
...
```

**指针** 一个指针类型可以用这种方式理解:
```
type *ptrToSth

struct ptrToSth
{
    int_(char*sizeof(void *)) address;
    type type
}
```
指针的宽度一般与寄存器相同.所以上面那个复杂的式子的意思是,address 是一个整数类型,其位数是指针类型的位数.64 位机器上是 64位,即 8 个字节,32 位机器上是 32 位,即 4 个字节.

对指针类型的增减,增减的单位是此指针类型中的那个类型.

在处理地址时,最好就是用 (char *)类型的数据,这样一来 `+-1` 就是对地址的增减.


limits.h CHAR_BIT



## 虚拟内存

### 虚拟内存解决了哪些问题,是如何解决的?解决问题的同时带来了什么副作用(需要进一步解决的问题)?

1. **内存容量不够的问题**: 

   **问题**: 如果没有虚拟内存,程序直接使用物理内存.当系统加载的程序超过了物理内存容量就会崩溃.

   **解决方案**: 借助虚拟内存,系统把超过物理内存的虚拟内存空间映射至磁盘.

   **副作用**: 性能问题.磁盘 IO 的性能问题.

2. **地址空间漏洞**:

   **问题**: 如果没有虚拟内存,那么程序线性映射到物理内内存,这样几乎总会留下一块没有使用却小于下一个要加载程序所需的空间的漏洞,无法充分利用物理内内存,资源浪费.

   **解决方案**: 借助虚拟内存,每个程序的虚拟内存把物理内存碎片化,把一整块虚拟地址映射到磁盘上的碎片空间.

3. **程序安全性:**

    **问题**: 如果没有虚拟内存,多个程序可能同时对一个地址进行读写,造成数据错误等问题.

    **解决方案**: 每个程序有独立的虚拟内存,分别把同一个虚拟地址映射到物理内存的不同地址,进而把程序隔离.

    **副作用**: 有些程序需要共享资源,包括一些程序库/多媒体资源等,虚拟内存似乎让程序分隔,无法共享资源.

    **副作用的解决方案**: 把相同的资源映射到同一物理地址.

参考资料  [YouTube: 虚拟内存](https://www.youtube.com/watch?v=59rEMnKWoS4&list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX&index=4)

## 存储器概览

- 存储 BIOS 信息:**EEPROM**,Electrically Erasable Programmable Read Only Memory  电可擦写可编程只读存储器,断电后仍可保存
- 存储临时工作数据: **DRAM**,Dynamic Random Access Memory 动态随机访问存储器,需要通电刷新,断电后数据消失
- 在CPU中存储常用指令与数据:**SRAM**,Static Random Access Memory 静态随机访问存储器,数据无需通电刷新,断电后数据消失

断电后数据不消失统称为**非易失性（或非发挥性）随机访问存储器,NVRAM**,即Non-Volatile Random Access Memory.反之称为 VRAM.

[参考链接](https://blog.csdn.net/x86ipc/article/details/5950436)

## 硬件相关


- **CMOS**: [Complementary Metal Oxide Semiconductor](https://baike.baidu.com/item/CMOS/428167?fr=aladdin),互补金属氧化物半导体,电脑主板上的一块可读写的RAM芯片.由于可读写,所以常用于保存计算机基本启动信息（如日期、时间、启动设置等）.
- RTC: Real Time Clock: 使计算机的时间实时最新的芯片.
