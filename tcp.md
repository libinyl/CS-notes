# TCP

## TCP 的要素

- connection    连接
- reliability   可靠
- flow control  流量控制
- full-duplex   全双工

## TCP的可靠是指什么?

并不是一定能把数据运输过去,而是如果能运送到,则运送到的一定是正确的;如果无法运送到,则提供通知.

- 数据的可靠递送
- 故障的可靠通知


## 信息

- RTT: round-trip time 往返时间.tcp 可以估算等待一个确认需要多久时间.
- 每个字节关联一个序列号(SEQ,sequencing),对发送的数据进行排序.
- 接收方将数据按序列号排序,若序列号有重复则丢弃对应数据
- tcp总是告知对端他一次能从对端接受多少数据,即通告窗口(advertised window),用以确保发送端发送的数据不会使接收缓冲区溢出.此窗口动态变化.
- tcp共 11 个状态.
- 源码在`netinet/tcp.h`
- 主动关闭的一端经历`TIME_WAIT`

## TIME_WAIT 存在的意义是什么?

- 实现 TCP 的全双工连接终止(即处理最后的 ACK 丢失的情形)
- 允许老旧的重复分节从网络中消失

## inode 号有什么用?

## TIME_WAIT 与 CLOSE_WAIT 分别触发的时机和区别?

## 流量控制解决了什么问题?

避免接收方的接收速度赶不上发送方的速度.给发送方指定一个速率,发送方发送的数据绝不超过这个速率.即窗口通告.

## 其他信息

- 操作系统用各种机制保证每个连接有不重复的初始序列号.
- 最简单的验证方式是用 telnet 检测某个主机的 80 端口,只会建立 tcp 连接而不会交流任何数据.
- 四次挥手是全双工通信的结束逻辑.

## wireshark 过滤技巧



**捕获过滤器**

过滤发送/来自某个主机的数据包:`host 10.3.1.1` 抓取发到/来自10.3.1.1的数据流


## 如何建立连接?

- C->S: 
  - Seq = ISN(c) & SYN (带位的序列号,即客户端初始序列号)
- S->C: 
  - 1) ACK = ISN(c)+1 ,对客户端序列号的确认
  - 2) Seq = ISN(s) & SYN (带位的序列号,即服务端初始序列号)
- C->S: 
  - 1) ACK = ISN(s)+1 ,对服务端序列号的确认
  - 2) Seq = ISN(c)+1 ,不带位的序列号,对服务端确认号的确认.

每个链接可能含一些 option.

## 普通序列号与初始序列号有什么不同?

- 对于初始序列号, 对方回复的ACK 是其+1.
- 对于普通序列号, 序列号的值是当前 session 的段的第一个字节的积累值.

## 如何关闭连接?

- 只有双方都关闭,才是完整的关闭.
- 服务端和客户端都可发起关闭.
- 关闭的过程,就是互相对 FIN 的相应的过程.

**以客户端发起关闭为例**

- C->S: 
  - FIN
  - ACK,用于确认最后一次传输,注意不是 last ack,last ack 是状态之一
  - Seq=K
- S->C:
  - ACK=K+1,用于确认客户端序列号
  - Seq=L

此时 C->S方向的连接可以看做是已经关闭.接下来是 S->C 方向的关闭.

- S->C:(增加了一个 FIN)
  - FIN
  - ACK=K+1
  - Seq=L
- C->S:
  - ACK=L+1
  - Seq=K

## 为什么 time_wait 状态是必需的


1. 尽可能保证被动关闭的一方收到最后的 ACK.

被动关闭方发送了最后的 FIN,会等待主动关闭方的 ACK.如果没有收到,会在此发送 FIN.如果主动关闭方返回了 ACK,将不能保证发送方一定能收到,错过了后序到来的 FIN.所以设定这个时间2MSL,过了这个时间仍没有收到被动关闭方的新的 FIN,就认为其已经收到了 ACK.

## 什么是 time_wait?

- net.ipv4.tcp_fin_timeout 记录了需要等待的超时时间.
- 发起关闭的一方,在关闭了自己到对方方向的传输之后,收到来自对方的 FIN,然后返回一个 ACK,进入 TIME_WAIT 状态.

## 状态说明

- LAST_ACK: 被动关闭以防等待主动一方最后的ACK

## 滑动窗口的作用是什么?

- 提供可靠性
- 提供流量控制

## 什么是滑动窗口?

- http://blog.sina.com.cn/s/blog_c5c2d6690102wpxl.html

- https://www.zhihu.com/question/32255109/answer/68558623

此字段用于告知对端,自己能接收的数据量.

- 三次握手协商出: window size scaling factor,即滑动窗口因子;

- 之后交互中的数据中传输的是 window size value,

- 最终的结果是二者之积.

- 最终发送速率=min(拥塞窗口, 接收窗口)

### 滑动窗口的机制是怎样的?

- 接收方接收到发送方的数据后,相应 ACK.

- 这个 ACK 中包含一个窗口大小(window),告知发送方自己的窗口大小,从而提醒控制方控制发送速度.

- 这个 ACK 还包含一个序列号 n ,是它期待收到的下一字节的序号. n 代表接收方已经接收到了前 n-1 字节的数据

控制方获取了这个窗口大小 win 后,那么就可以计算出下次发的字节数.假如已经发送了 x 字节,那么下次发送的数据最多为

### 流量控制与拥塞控制

https://zhuanlan.zhihu.com/p/37379780

https://www.jianshu.com/p/2bc807fc6ff9

## 总结和常量

- 发送方准备数据,置于发送窗口中, 每次发送给对方的数据由 MSS 确定, 并指出自己的接收窗口大小. 
- 接收窗口大小 = win size * (2 ^ (win scale))


## 拥塞控制


- **慢启动**:连接刚建立,发送方对网络状况一无所知,所以拥塞窗口初始值大小非常小,RFC 建议是 2 倍到 4 倍的 MSS.
- 如果发出去的包都被确认了,表明没有到达拥塞点,可以增大拥塞窗口,增速较快,收到几个确认,就增加几个 MSS,是指数增长的.由于基数低,所以称此阶段为慢启动过程.
- **拥塞避免**:慢启动一段时间后,拥塞窗口到达某个临界值,要降低增长速度,每个往返时间增加 1 个 MSS,即拥塞避免算法.这个临界值的取值如何取?如果之前出现过拥塞,就等于那次的值,否则的话可以与最大接收窗口相等.
- **超时重传**:如果发出去的包得不到确认,则可能发生拥塞,如果等待一段时间还没有确认,则认定包丢失,只能重传.这个等待时间成为"RTO", RetransmissionTimeOut.
- 重传之后,

如果发生超时重传且性能影响不可忽略,可以缩小RTO来缓解.

- **快速重传**: 当收到比期望的 seq 号大的包时,没收到 1 个就回复一个对期望seq的ack,即重复确认. 当发送方收到 3 此或以上的重复确认时,就意识到相应的包已经丢了,立即重传.