# TCP

## TCP 的要素

- connection    连接
- reliability   可靠
- flow control  流量控制
- full-duplex   全双工

## TCP的可靠是指什么?

并不是一定能把数据运输过去,而是如果能运送到,则运送到的一定是正确的;如果无法运送到,则提供通知.

- 数据的可靠递送
- 故障的可靠通知


## 信息

- RTT: round-trip time 往返时间.tcp 可以估算等待一个确认需要多久时间.
- 每个字节关联一个序列号(SEQ,sequencing),对发送的数据进行排序.
- 接收方将数据按序列号排序,若序列号有重复则丢弃对应数据
- tcp总是告知对端他一次能从对端接受多少数据,即通告窗口(advertised window),用以确保发送端发送的数据不会使接收缓冲区溢出.此窗口动态变化.
- tcp共 11 个状态.
- 源码在`netinet/tcp.h`
- 主动关闭的一端经历`TIME_WAIT`

## TIME_WAIT 存在的意义是什么?

- 实现 TCP 的全双工连接终止(即处理最后的 ACK 丢失的情形)
- 允许老旧的重复分节从网络中消失

## inode 号有什么用?

## TIME_WAIT 与 CLOSE_WAIT 分别触发的时机和区别?

## 流量控制解决了什么问题?

避免接收方的接收速度赶不上发送方的速度.给发送方指定一个速率,发送方发送的数据绝不超过这个速率.即窗口通告.

## 其他信息

- 操作系统用各种机制保证每个连接有不重复的初始序列号.
- 最简单的验证方式是用 telnet 检测某个主机的 80 端口,只会建立 tcp 连接而不会交流任何数据.
- 四次挥手是全双工通信的结束逻辑.

## wireshark 过滤技巧



**捕获过滤器**

过滤发送/来自某个主机的数据包:`host 10.3.1.1` 抓取发到/来自10.3.1.1的数据流


## 如何建立连接?

- C->S: 
  - Seq = ISN(c) & SYN (带位的序列号,即客户端初始序列号)
- S->C: 
  - 1) ACK = ISN(c)+1 ,对客户端序列号的确认
  - 2) Seq = ISN(s) & SYN (带位的序列号,即服务端初始序列号)
- C->S: 
  - 1) ACK = ISN(s)+1 ,对服务端序列号的确认
  - 2) Seq = ISN(c)+1 ,不带位的序列号,对服务端确认号的确认.

每个链接可能含一些 option.

## 普通序列号与初始序列号有什么不同?

- 对于初始序列号, 对方回复的ACK 是其+1.
- 对于普通序列号, 序列号的值是当前 session 的段的第一个字节的积累值.

## 如何关闭连接?

- 只有双方都关闭,才是完整的关闭.
- 服务端和客户端都可发起关闭.
- 关闭的过程,就是互相对 FIN 的相应的过程.

**以客户端发起关闭为例**

- C->S: 
  - FIN
  - ACK,用于确认最后一次传输,注意不是 last ack,last ack 是状态之一
  - Seq=K
- S->C:
  - ACK=K+1,用于确认客户端序列号
  - Seq=L

此时 C->S方向的连接可以看做是已经关闭.接下来是 S->C 方向的关闭.

- S->C:(增加了一个 FIN)
  - FIN
  - ACK=K+1
  - Seq=L
- C->S:
  - ACK=L+1
  - Seq=K

## 为什么 time_wait 状态是必需的


1. 尽可能保证被动关闭的一方收到最后的 ACK.

被动关闭方发送了最后的 FIN,会等待主动关闭方的 ACK.如果没有收到,会在此发送 FIN.如果主动关闭方返回了 ACK,将不能保证发送方一定能收到,错过了后序到来的 FIN.所以设定这个时间2MSL,过了这个时间仍没有收到被动关闭方的新的 FIN,就认为其已经收到了 ACK.

## 什么是 time_wait?

- net.ipv4.tcp_fin_timeout 记录了需要等待的超时时间.
- 发起关闭的一方,在关闭了自己到对方方向的传输之后,收到来自对方的 FIN,然后返回一个 ACK,进入 TIME_WAIT 状态.

## 状态说明

- LAST_ACK: 被动关闭以防等待主动一方最后的ACK