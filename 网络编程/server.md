## 网络编程总结


迭代服务器: 瞬时服务,多用户
并发服务器: 长时服务,多用户


## tcp 与 socket

对 tcp socket 调用 close 会导致发送一个 `FIN`, 随后是正常的连接终止序列.

每个 socket 内部都有一个引用计数.父进程关闭了 socketfd,只是把此 socketfd 的引用计数-1.子进程也需要-1,才能完全释放 fd.


服务端:
socket()返回后,这个 listen socket 的引用计数为 1.

accept() 返回后得到的代表客户端的 clientfd 的 socket 的引用计数为 1.

close() 一个 tcp 套接字的默认行为是把该套接字标记为已关闭,然后立即返回到调用进程.

## 正常终止

1. 客户端断开, 向服务端发送 FIN,服务端子进程的 read 返回 0,然后 exit 终止, 此子进程的所有描述符关闭.其中关闭 socket cli 描述符时会触发向客户端的 FIN, 完成剩下两次挥手.
2. 子进程关闭后,向父进程发送信号 SIGCHLD,如果父进程忽略,则子进程进入僵死状态.
3. 需要用信号处理机制清理僵死进程.

## 多进程编程常识

只要 fork,就必须 wait.否则会一直有僵尸进程,直到主进程退出.

需要俘获 SIGCHLD 信号.

## 服务器崩溃后发生了什么?

1. 向客户端发送 FIN
2. 客户端收到 FIN.  

此时客户端并不能确认

## 字节序转换

inet_ntop: ip地址网络转本地
ntohs: 转换端口号

## TIME_WAIT 的意义

发送完最后的 ACK 之后,主动断开方无法知道对方是否接收到 ACK.如果对方没收到 ACK,这个 2MSl 的时间,主动断开方还能收到FIN的重传. 如果 2MSL 之后还没收到 FIN 重传,就认为对方已经收到 最终的 ACK.

## SIGPIPE

向一个已关闭的 socket 写入数据, 会触发错误, SIGPIPE 信号. 所以服务端有必要捕捉此信号.

第一次写操作引发 RST，第二次写引发 SIGPIPE 信号。写一个已接收了FIN的套接字不成问题，但是写一个已接收了 RST 的套接字则是一个错误。